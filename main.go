/*The following code was generated by Claude and further refined by hand.*/

package main

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	"golang.org/x/tools/present"
)

var articles []string = []string{
	"welcome.article",
	"basics.article",
	"flowcontrol.article",
	"moretypes.article",
	"methods.article",
	"generics.article",
	"concurrency.article",
}

func parseArticle(filename string) (*present.Doc, error) {

	// Read the file content
	content, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	// Preprocess to include #appengine sections
	// Remove the "#appengine: " prefix from lines
	lines := strings.Split(string(content), "\n")
	var processed []string
	for _, line := range lines {
		if strings.HasPrefix(line, "#appengine: ") {
			// Remove the "#appengine: " prefix (12 characters)
			processed = append(processed, line[12:])
		} else if strings.HasPrefix(line, "#appengine:") && len(line) == 11 {
			// Handle lines that are just "#appengine:" without content
			processed = append(processed, "")
		} else {
			processed = append(processed, line)
		}
	}
	processedContent := strings.Join(processed, "\n")

	// Parse the preprocessed content
	doc, err := present.Parse(strings.NewReader(processedContent), filename, 0)
	if err != nil {
		return nil, err
	}

	return doc, nil
}

func convertLinkSyntax(text string) string {

	// Convert [[url][text]] to [text](url)
	re := regexp.MustCompile(`\[\[([^\]]+)\]\[([^\]]+)\]\]`)
	converted := re.ReplaceAllStringFunc(text, func(match string) string {
		// Extract URL and text from the match
		submatches := re.FindStringSubmatch(match)
		if len(submatches) != 3 {
			return match
		}
		url := submatches[1]
		linkText := submatches[2]

		// Add https://go.dev prefix to relative links
		if isRelativeLink(url) {
			url = "https://go.dev" + url
		}

		return fmt.Sprintf("[%s](%s)", linkText, url)
	})

	// Remove JavaScript links entirely
	return removeJavaScriptLinks(converted)
}

func isRelativeLink(url string) bool {
	// A link is relative if it doesn't start with:
	// - http:// or https://
	// - javascript:
	// - mailto:
	// - # (anchor)
	return !strings.HasPrefix(url, "http://") &&
		!strings.HasPrefix(url, "https://") &&
		!strings.HasPrefix(url, "javascript:") &&
		!strings.HasPrefix(url, "mailto:") &&
		!strings.HasPrefix(url, "#")
}

func removeJavaScriptLinks(text string) string {
	// Replace [text](javascript:...) with just the text (without brackets or link)
	// The regex matches the full markdown link including the )) at the end
	// (one ) from javascript function, one ) from markdown link)
	re := regexp.MustCompile(`\[([^\]]+)\]\(javascript:[^\)]*\)\)`)
	return re.ReplaceAllString(text, "$1")
}

func convertToMarkdown(doc *present.Doc, articleName string) string {

	var md strings.Builder

	// Title
	md.WriteString("# ")
	md.WriteString(doc.Title)
	md.WriteString("\n\n")

	// Subtitle
	if doc.Subtitle != "" {
		md.WriteString("*")
		md.WriteString(convertLinkSyntax(doc.Subtitle))
		md.WriteString("*\n")
	}

	// Author
	//for _, author := range doc.Authors {
	//	md.WriteString("*Author: ")
	//	if len(author.Elem) > 0 {
	//		if text, ok := author.Elem[0].(present.Text); ok && len(text.Lines) > 0 {
	//			md.WriteString(text.Lines[0])
	//		}
	//	}
	//	md.WriteString("*\n")
	//}

	md.WriteString("\n---\n\n")

	goDevUrlPrefix := "https://go.dev/tour"
	aname := strings.Split(articleName, ".")[0]

	// Sections
	for i, section := range doc.Sections {

		goPageUrl := fmt.Sprintf("%s/%s/%d", goDevUrlPrefix, aname, i+1)

		md.WriteString("## ")
		md.WriteString(fmt.Sprintf("[%s](%s)", section.Title, goPageUrl))
		md.WriteString("\n\n")

		for _, elem := range section.Elem {
			switch e := elem.(type) {
			case present.Text:
				// Check if this is preformatted text (code snippet)
				if e.Pre {
					// Preformatted text - wrap in code block with go syntax
					md.WriteString("\n```go\n")
					for _, line := range e.Lines {
						md.WriteString(line)
						md.WriteString("\n")
					}
					md.WriteString("```\n\n")
				} else {
					// Regular text
					for _, line := range e.Lines {
						md.WriteString(convertLinkSyntax(line))
						md.WriteString("\n")
					}
					md.WriteString("\n")
				}

			case present.Code:
				// Include the filename if available
				if e.FileName != "" {
					md.WriteString("**")
					md.WriteString(e.FileName)
					md.WriteString(":**\n")
				}
				md.WriteString("```go\n")
				md.Write(e.Raw)
				if len(e.Raw) > 0 && e.Raw[len(e.Raw)-1] != '\n' {
					md.WriteString("\n")
				}
				md.WriteString("```\n\n")

			case present.List:
				for _, item := range e.Bullet {
					md.WriteString("- ")
					md.WriteString(convertLinkSyntax(item))
					md.WriteString("\n")
				}
				md.WriteString("\n")
			}
		}
	}

	return md.String()
}

func main() {

	outputFile := "README.md"
	var combinedMarkdown strings.Builder

	combinedMarkdown.WriteString("*[A Tour of Go](https://go.dev/tour/welcome/1) on a single web page to easily find what you want to recall.*\n\n")

	combinedMarkdown.WriteString("Note: if you want to run the code, you can click on a section heading, which will redirect you to the corresponding part of A Tour of Go where you can run the code.\n\n")

	combinedMarkdown.WriteString("This adaptation of [A Tour of Go](https://go.dev/tour/welcome/1) is in compliance with the BSD license under which the original is distributed ([LICENSE](https://cs.opensource.google/go/x/website/+/master:LICENSE)).\n\n")

	for i, articleName := range articles {
		inputFile := "website/_content/tour/" + articleName

		fmt.Printf("Processing %s...\n", articleName)

		doc, err := parseArticle(inputFile)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing article %s: %v\n", articleName, err)
			os.Exit(1)
		}

		markdown := convertToMarkdown(doc, articleName)
		combinedMarkdown.WriteString(markdown)

		// Add separator between articles (except after the last one)
		if i < len(articles)-1 {
			combinedMarkdown.WriteString("\n\n---\n\n")
		}
	}

	err := os.WriteFile(outputFile, []byte(combinedMarkdown.String()), 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error writing markdown file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\nSuccessfully converted all articles to %s\n", outputFile)
}
