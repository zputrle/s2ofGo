/*The following code was generated by Claude and further refined by hand.*/

package main

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	"golang.org/x/tools/present"
)

var articles []string = []string{
	"welcome.article",
	"basics.article",
	"flowcontrol.article",
	"moretypes.article",
	"methods.article",
	"generics.article",
	"concurrency.article",
}

func parseArticle(filename string) (*present.Doc, error) {

	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	doc, err := present.Parse(file, filename, 0)
	if err != nil {
		return nil, err
	}

	return doc, nil
}

func convertLinkSyntax(text string) string {

	// Convert [[url][text]] to [text](url)
	re := regexp.MustCompile(`\[\[([^\]]+)\]\[([^\]]+)\]\]`)
	converted := re.ReplaceAllStringFunc(text, func(match string) string {
		// Extract URL and text from the match
		submatches := re.FindStringSubmatch(match)
		if len(submatches) != 3 {
			return match
		}
		url := submatches[1]
		linkText := submatches[2]

		// Add https://go.dev prefix to relative links
		if isRelativeLink(url) {
			url = "https://go.dev" + url
		}

		return fmt.Sprintf("[%s](%s)", linkText, url)
	})

	// Remove JavaScript links entirely
	return removeJavaScriptLinks(converted)
}

func isRelativeLink(url string) bool {
	// A link is relative if it doesn't start with:
	// - http:// or https://
	// - javascript:
	// - mailto:
	// - # (anchor)
	return !strings.HasPrefix(url, "http://") &&
		!strings.HasPrefix(url, "https://") &&
		!strings.HasPrefix(url, "javascript:") &&
		!strings.HasPrefix(url, "mailto:") &&
		!strings.HasPrefix(url, "#")
}

func removeJavaScriptLinks(text string) string {
	// Replace [text](javascript:...) with just the text (without brackets or link)
	// The regex matches the full markdown link including the )) at the end
	// (one ) from javascript function, one ) from markdown link)
	re := regexp.MustCompile(`\[([^\]]+)\]\(javascript:[^\)]*\)\)`)
	return re.ReplaceAllString(text, "$1")
}

func convertToMarkdown(doc *present.Doc, articleName string) string {

	var md strings.Builder

	// Title
	md.WriteString("# ")
	md.WriteString(doc.Title)
	md.WriteString("\n\n")

	// Subtitle
	if doc.Subtitle != "" {
		md.WriteString("*")
		md.WriteString(convertLinkSyntax(doc.Subtitle))
		md.WriteString("*\n")
	}

	// Author
	//for _, author := range doc.Authors {
	//	md.WriteString("*Author: ")
	//	if len(author.Elem) > 0 {
	//		if text, ok := author.Elem[0].(present.Text); ok && len(text.Lines) > 0 {
	//			md.WriteString(text.Lines[0])
	//		}
	//	}
	//	md.WriteString("*\n")
	//}

	md.WriteString("\n---\n\n")

	goDevUrlPrefix := "https://go.dev/tour"
	aname := strings.Split(articleName, ".")[0]

	// Sections
	for i, section := range doc.Sections {

		goPageUrl := fmt.Sprintf("%s/%s/%d", goDevUrlPrefix, aname, i+1)

		md.WriteString("## ")
		md.WriteString(fmt.Sprintf("[%s](%s)", section.Title, goPageUrl))
		md.WriteString("\n\n")

		for _, elem := range section.Elem {
			switch e := elem.(type) {
			case present.Text:
				// Check if this is preformatted text (code snippet)
				if e.Pre {
					// Preformatted text - wrap in code block with go syntax
					md.WriteString("\n```go\n")
					for _, line := range e.Lines {
						md.WriteString(line)
						md.WriteString("\n")
					}
					md.WriteString("```\n\n")
				} else {
					// Regular text
					for _, line := range e.Lines {
						md.WriteString(convertLinkSyntax(line))
						md.WriteString("\n")
					}
					md.WriteString("\n")
				}

			case present.Code:
				md.WriteString("```go\n")
				md.Write(e.Raw)
				if len(e.Raw) > 0 && e.Raw[len(e.Raw)-1] != '\n' {
					md.WriteString("\n")
				}
				md.WriteString("```\n\n")

			case present.List:
				for _, item := range e.Bullet {
					md.WriteString("- ")
					md.WriteString(convertLinkSyntax(item))
					md.WriteString("\n")
				}
				md.WriteString("\n")
			}
		}
	}

	return md.String()
}

func main() {

	outputFile := "README.md"
	var combinedMarkdown strings.Builder

	combinedMarkdown.WriteString("[A Tour of Go](https://go.dev/tour/welcome/1) on a single web page to easily find what you want to recall.\n\n")

	for i, articleName := range articles {
		inputFile := "website/_content/tour/" + articleName

		fmt.Printf("Processing %s...\n", articleName)

		doc, err := parseArticle(inputFile)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error parsing article %s: %v\n", articleName, err)
			os.Exit(1)
		}

		markdown := convertToMarkdown(doc, articleName)
		combinedMarkdown.WriteString(markdown)

		// Add separator between articles (except after the last one)
		if i < len(articles)-1 {
			combinedMarkdown.WriteString("\n\n---\n\n")
		}
	}

	err := os.WriteFile(outputFile, []byte(combinedMarkdown.String()), 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error writing markdown file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\nSuccessfully converted all articles to %s\n", outputFile)
}
